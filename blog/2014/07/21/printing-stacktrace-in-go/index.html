<!doctype html><html><head>
<meta charset=utf-8>
<meta http-equiv=x-ua-compatible content="IE=edge"><title>在 Go 中获取 stacktrace - Timon Wong</title><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="buf := make([]byte, 1<<16) // 获取 **所有** goroutine 的 stacktrace runtime.Stack(buf, true) // 如果需要获取 **当前** goroutine 的 stacktrace, 第二个参数需要为 `false` runtime.Stack(buf, true) fmt.Println(string(buf)) 太诡异了，居然要指定 buffer 的大小，用起来不方便。虽然可以给个“足够大” buffer 用来容纳 stacktrace，但是什么是“足够大”？
为了确认 runtime.Stack() 函数的 behavior，需要参考一下 Go 输出 stacktrace 的实现代码。该代码是使用 GOC 写成的。
 A .goc file is a combination of a limited form of Go with C.
 func Stack(b Slice, all bool) (n int) { uintptr pc, sp; // Stack pointer  sp = runtime·getcallersp(&b); // Programer pointer  pc = (uintptr)runtime·getcallerpc(&b); // 如果选择输出所有 goroutine 的 traceback, 挂起所有goroutine,  // 在本函数完成后恢复  if(all) { runtime·semacquire(&runtime·worldsema, false); m->gcing = 1; runtime·stoptheworld(); } if(b.">
<meta property="og:image" content>
<meta property="og:title" content="在 Go 中获取 stacktrace">
<meta property="og:description" content="buf := make([]byte, 1<<16) // 获取 **所有** goroutine 的 stacktrace runtime.Stack(buf, true) // 如果需要获取 **当前** goroutine 的 stacktrace, 第二个参数需要为 `false` runtime.Stack(buf, true) fmt.Println(string(buf)) 太诡异了，居然要指定 buffer 的大小，用起来不方便。虽然可以给个“足够大” buffer 用来容纳 stacktrace，但是什么是“足够大”？
为了确认 runtime.Stack() 函数的 behavior，需要参考一下 Go 输出 stacktrace 的实现代码。该代码是使用 GOC 写成的。
 A .goc file is a combination of a limited form of Go with C.
 func Stack(b Slice, all bool) (n int) { uintptr pc, sp; // Stack pointer  sp = runtime·getcallersp(&b); // Programer pointer  pc = (uintptr)runtime·getcallerpc(&b); // 如果选择输出所有 goroutine 的 traceback, 挂起所有goroutine,  // 在本函数完成后恢复  if(all) { runtime·semacquire(&runtime·worldsema, false); m->gcing = 1; runtime·stoptheworld(); } if(b.">
<meta property="og:type" content="article">
<meta property="og:url" content="https://theo.im/blog/2014/07/21/printing-stacktrace-in-go/"><meta property="article:section" content="posts">
<meta property="article:published_time" content="2014-07-21T21:30:12+00:00">
<meta property="article:modified_time" content="2014-07-21T21:30:12+00:00">
<meta name=twitter:card content="summary">
<meta name=twitter:title content="在 Go 中获取 stacktrace">
<meta name=twitter:description content="buf := make([]byte, 1<<16) // 获取 **所有** goroutine 的 stacktrace runtime.Stack(buf, true) // 如果需要获取 **当前** goroutine 的 stacktrace, 第二个参数需要为 `false` runtime.Stack(buf, true) fmt.Println(string(buf)) 太诡异了，居然要指定 buffer 的大小，用起来不方便。虽然可以给个“足够大” buffer 用来容纳 stacktrace，但是什么是“足够大”？
为了确认 runtime.Stack() 函数的 behavior，需要参考一下 Go 输出 stacktrace 的实现代码。该代码是使用 GOC 写成的。
 A .goc file is a combination of a limited form of Go with C.
 func Stack(b Slice, all bool) (n int) { uintptr pc, sp; // Stack pointer  sp = runtime·getcallersp(&b); // Programer pointer  pc = (uintptr)runtime·getcallerpc(&b); // 如果选择输出所有 goroutine 的 traceback, 挂起所有goroutine,  // 在本函数完成后恢复  if(all) { runtime·semacquire(&runtime·worldsema, false); m->gcing = 1; runtime·stoptheworld(); } if(b.">
<script src=https://theo.im/js/feather.min.js></script>
<link href=https://theo.im/css/fonts.b685ac6f654695232de7b82a9143a46f9e049c8e3af3a21d9737b01f4be211d1.css rel=stylesheet>
<link rel=stylesheet type=text/css media=screen href=https://theo.im/css/main.2f9b5946627215dc1ae7fa5f82bfc9cfcab000329136befeea5733f21e77d68f.css>
</head>
<body>
<div class=content><header>
<div class=main>
<a href=https://theo.im/>Timon Wong</a>
</div>
<nav>
<a href=/>Home</a>
<a href=/posts>Posts</a>
<a href=/tags>Tags</a>
</nav>
</header>
<main>
<article>
<div class=title>
<h1 class=title>在 Go 中获取 stacktrace</h1>
<div class=meta>Posted on Jul 21, 2014</div>
</div>
<section class=body>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>1</span><span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>16</span>)
<span style=color:#75715e>// 获取 **所有** goroutine 的 stacktrace
</span><span style=color:#75715e></span><span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Stack</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#66d9ef>true</span>)
<span style=color:#75715e>// 如果需要获取 **当前** goroutine 的 stacktrace, 第二个参数需要为 `false`
</span><span style=color:#75715e></span><span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Stack</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#66d9ef>true</span>)
<span style=color:#a6e22e>fmt</span>.<span style=color:#a6e22e>Println</span>(string(<span style=color:#a6e22e>buf</span>))
</code></pre></div><p>太诡异了，居然要指定 buffer 的大小，用起来不方便。虽然可以给个“足够大” buffer 用来容纳
stacktrace，但是什么是“足够大”？</p>
<p>为了确认 <code>runtime.Stack()</code> 函数的 behavior，需要参考一下 Go 输出 stacktrace 的实现代码。该代码是使用 <a href=https://code.google.com/p/go/source/browse/src/cmd/dist/goc2c.c>GOC</a> 写成的。</p>
<blockquote>
<p>A .goc file is a combination of a limited form of Go with C.</p>
</blockquote>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>Stack</span>(<span style=color:#a6e22e>b</span> <span style=color:#a6e22e>Slice</span>, <span style=color:#a6e22e>all</span> <span style=color:#66d9ef>bool</span>) (<span style=color:#a6e22e>n</span> <span style=color:#66d9ef>int</span>) {
    <span style=color:#66d9ef>uintptr</span> <span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>;

    <span style=color:#75715e>// Stack pointer
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>sp</span> = <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>getcallersp</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>);
    <span style=color:#75715e>// Programer pointer
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>pc</span> = (<span style=color:#66d9ef>uintptr</span>)<span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>getcallerpc</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>b</span>);

    <span style=color:#75715e>// 如果选择输出所有 goroutine 的 traceback, 挂起所有goroutine,
</span><span style=color:#75715e></span>    <span style=color:#75715e>// 在本函数完成后恢复
</span><span style=color:#75715e></span>    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>all</span>) {
        <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>semacquire</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>worldsema</span>, <span style=color:#66d9ef>false</span>);
        <span style=color:#a6e22e>m</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>gcing</span> = <span style=color:#ae81ff>1</span>;
        <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>stoptheworld</span>();
    }

    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>len</span> <span style=color:#f92672>==</span> <span style=color:#ae81ff>0</span>)
        <span style=color:#a6e22e>n</span> = <span style=color:#ae81ff>0</span>;
    <span style=color:#66d9ef>else</span>{
        <span style=color:#75715e>// 重定向输出缓冲, 打印到 `b` 这个buffer里
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>g</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>writebuf</span> = (<span style=color:#66d9ef>byte</span><span style=color:#f92672>*</span>)<span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>array</span>;
        <span style=color:#75715e>// buffer具有固定大小, 因此会截断
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>g</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>writenbuf</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>len</span>;
        <span style=color:#75715e>// proc.c: runtime·goroutineheader
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>goroutineheader</span>(<span style=color:#a6e22e>g</span>);
        <span style=color:#75715e>// traceback_${arch}.c
</span><span style=color:#75715e></span>        <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>traceback</span>(<span style=color:#a6e22e>pc</span>, <span style=color:#a6e22e>sp</span>, <span style=color:#ae81ff>0</span>, <span style=color:#a6e22e>g</span>);
        <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>all</span>)
            <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>tracebackothers</span>(<span style=color:#a6e22e>g</span>);
        <span style=color:#a6e22e>n</span> = <span style=color:#a6e22e>b</span>.<span style=color:#a6e22e>len</span> <span style=color:#f92672>-</span> <span style=color:#a6e22e>g</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>writenbuf</span>;
        <span style=color:#a6e22e>g</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>writebuf</span> = <span style=color:#66d9ef>nil</span>;
        <span style=color:#a6e22e>g</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>writenbuf</span> = <span style=color:#ae81ff>0</span>;
    }

    <span style=color:#66d9ef>if</span>(<span style=color:#a6e22e>all</span>) {
        <span style=color:#a6e22e>m</span><span style=color:#f92672>-</span>&gt;<span style=color:#a6e22e>gcing</span> = <span style=color:#ae81ff>0</span>;
        <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>semrelease</span>(<span style=color:#f92672>&amp;</span><span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>worldsema</span>);
        <span style=color:#a6e22e>runtime</span><span style=color:#960050;background-color:#1e0010>·</span><span style=color:#a6e22e>starttheworld</span>();
    }
}
</code></pre></div><p>因为打印到buffer会截断过长的结果，因此可以写一个包装函数：</p>
<div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-go data-lang=go><span style=color:#66d9ef>func</span> <span style=color:#a6e22e>StackTrace</span>(<span style=color:#a6e22e>all</span> <span style=color:#66d9ef>bool</span>) <span style=color:#66d9ef>string</span> {
    <span style=color:#75715e>// Reserve 10K buffer at first
</span><span style=color:#75715e></span>    <span style=color:#a6e22e>buf</span> <span style=color:#f92672>:=</span> make([]<span style=color:#66d9ef>byte</span>, <span style=color:#ae81ff>10240</span>)

    <span style=color:#66d9ef>for</span> {
        <span style=color:#a6e22e>size</span> <span style=color:#f92672>:=</span> <span style=color:#a6e22e>runtime</span>.<span style=color:#a6e22e>Stack</span>(<span style=color:#a6e22e>buf</span>, <span style=color:#a6e22e>all</span>)
        <span style=color:#75715e>// The size of the buffer may be not enough to hold the stacktrace,
</span><span style=color:#75715e></span>        <span style=color:#75715e>// so double the buffer size
</span><span style=color:#75715e></span>        <span style=color:#66d9ef>if</span> <span style=color:#a6e22e>size</span> <span style=color:#f92672>==</span> len(<span style=color:#a6e22e>buf</span>) {
            <span style=color:#a6e22e>buf</span> = make([]<span style=color:#66d9ef>byte</span>, len(<span style=color:#a6e22e>buf</span>)<span style=color:#f92672>&lt;&lt;</span><span style=color:#ae81ff>1</span>)
            <span style=color:#66d9ef>continue</span>
        }
        <span style=color:#66d9ef>break</span>
    }

    <span style=color:#66d9ef>return</span> string(<span style=color:#a6e22e>buf</span>)
}

</code></pre></div><p>例子可以在这里看到：<a href=http://play.golang.org/p/4ABrCVbH9g>Go Playground</a></p>
</section>
<div class=post-tags>
</div>
</article>
</main>
<footer>
<hr><a class=soc href=https://github.com/timonwong title=GitHub><i data-feather=github></i></a>|⚡️
2021 © timonwong | <a href=https://github.com/athul/archie>Archie Theme</a> | Built with <a href=https://gohugo.io>Hugo</a>
</footer>
<script>feather.replace()</script></div>
</body>
</html>