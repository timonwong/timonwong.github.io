<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Timon Wong</title><link>https://theo.im/</link><description>Recent content on Timon Wong</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© timonwong</copyright><lastBuildDate>Tue, 17 Oct 2017 00:00:00 +0000</lastBuildDate><atom:link href="https://theo.im/index.xml" rel="self" type="application/rss+xml"/><item><title>使用 Minio 为阿里云 OSS 提供 AWS S3 兼容 API</title><link>https://theo.im/blog/2017/10/17/use-minio-with-aliyun-oss/</link><pubDate>Tue, 17 Oct 2017 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2017/10/17/use-minio-with-aliyun-oss/</guid><description>&lt;h2 id="summary">Summary&lt;/h2>
&lt;p>不可否认，现在互联网的一个大「单点」就是对象存储 &lt;a href="https://aws.amazon.com/s3">Amazon S3&lt;/a> 了，大量的应用使用了 S3 的 API，这带来了一个问题，就是应用难于迁移。虽然改客户端这层这个方法，但毕竟侵入性太大，对于一个拥有众多服务的系统来说，实现的成本比较高。&lt;/p>
&lt;p>还有另外一种方案，就是提供一个 Gateway，提供与 S3 兼容的 API 供原来的客户端使用；中转请求后打入其它类型的对象存储中（本文为阿里云 &lt;a href="https://www.aliyun.com/product/oss">OSS&lt;/a>）。&lt;/p></description></item><item><title>将钉钉接入 Prometheus AlertManager WebHook</title><link>https://theo.im/blog/2017/10/16/release-prometheus-alertmanager-webhook-for-dingtalk/</link><pubDate>Mon, 16 Oct 2017 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2017/10/16/release-prometheus-alertmanager-webhook-for-dingtalk/</guid><description>&lt;h2 id="tldr">TL;DR&lt;/h2>
&lt;p>&lt;strong>Disclaimer&lt;/strong>: Personally I dislike &lt;a href="https://www.dingtalk.com">DingTalk&lt;/a>(a.k.a DingDing) at all 😜.&lt;/p>
&lt;p>Project Repo: &lt;a href="https://github.com/timonwong/prometheus-webhook-dingtalk">https://github.com/timonwong/prometheus-webhook-dingtalk&lt;/a>&lt;/p></description></item><item><title>解决 AWS ELB 偶发的 502 Bad Gateway 错误</title><link>https://theo.im/blog/2017/10/14/suspicious-502-error-from-elb/</link><pubDate>Sat, 14 Oct 2017 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2017/10/14/suspicious-502-error-from-elb/</guid><description>问题描述 在使用了 Prometheus blackbox_exporter 做了 HTTP 协议的监控之后，blackbox_exporter 偶尔会报一些 ProbeDown 的报警，经过检查是 502 Bad Gateway 错误，但此时后端是正常的，只是在 AWS ELB 的监控指标中，看到了 ELB HTTP 5xx 相关错误，因此困扰了一段时间。
HTTP 数据流向如下：
[Client] --- [ELB] --- [nginx] --- [App Servers] 排查问题 最开始是怀疑是后端问题，但是查阅了 nginx 和 App servers 的日志，没有任何结果，只是在 ELB 日志里面找到了 502 Bad Gateway 的错误信息。无奈之下甚至怀疑 nginx 所在 EC2 instance 有问题，因此求助了 AWS 技术支持。根据建议，在 nginx 这端做了 tcpdump 抓包，最后终于在 AWS 技术支持的帮助下，定位并解决了问题 🎉。
先补充一个知识：如果后端支持的话，ELB 会使用保持连接（HTTP persistent/keep-alive connections）。来看看这一个保持连接的 TCP stream：
其中，10.100.2.186 是 ELB 内部 IP，10.100.250.22 是 nginx 服务器内部 IP。这样，可以看到：</description></item><item><title>试用最新的 Docker for Mac Beta</title><link>https://theo.im/blog/2016/05/22/evaluating-new-docker-for-mac-beta/</link><pubDate>Sun, 22 May 2016 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2016/05/22/evaluating-new-docker-for-mac-beta/</guid><description>DEPRECATION: 现在 Docker for Mac 已经可以通过界面配置 mirror 了，这片文章作废
如何申请 Docker for Mac Beta 请访问这个地址申请，可能需要等几天：https://beta.docker.com/
Docker for Mac Beta，最大的好处就是不再依赖 VirtualBox VM 了，而是使用了更轻量化的 xhyve 作为其虚拟化方案（也即是说，仍然不是原生的，还是需要虚拟化一个 Linux 出来在上面运行 Docker Daemon）。
另外，这个版本的 Docker for Mac 使用了 Alpine Linux 发行版，作为一个更轻量化的发行版，与一般的发行版有不少区别，比如，使用 ash 替换 bash 等，具体请访问 Alpine Linux 网站获取更多信息。
使用 Docker Hub Registry Mirror 由于众所周知的原因，在国内访问 Docker Hub 的速度相当缓慢，因此需要设置一个 Docker Registry Mirror 来加速，这里使用 USTC 的 Docker Hub Mirror。
就如同之前所说，Alpine Linux 发行版与一般发行版有巨大区别，因此调整 Docker Daemon 的启动参数也不大一样😂
Quick Way NOTE: 安装了 jq 命令行工具（可以通过 brew install jq 安装），可以直接执行一行命令行搞定，否则请参阅「Slow Way」一节：</description></item><item><title>在 Python 中统计文本字符个数</title><link>https://theo.im/blog/2014/08/13/count-text-element-count-in-python/</link><pubDate>Wed, 13 Aug 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/08/13/count-text-element-count-in-python/</guid><description>&lt;p>字符集向来都是一个大问题，即使是 Python 3.x，也最多只是能说感谢 &lt;a href="http://en.wikipedia.org/wiki/Unicode">Unicode&lt;/a> 字符集，字符串的存取现在没有问题了。&lt;/p>
&lt;p>Unicode 字符集的常见&lt;strong>编码&lt;/strong>有 &lt;a href="http://en.wikipedia.org/wiki/UTF-8">UTF-8&lt;/a>、&lt;a href="http://en.wikipedia.org/wiki/UTF-16">UTF-16&lt;/a>、&lt;a href="http://en.wikipedia.org/wiki/UTF-32">UTF-32&lt;/a> 等常见格式，另外，&lt;a href="http://en.wikipedia.org/wiki/GB_18030">GB18030&lt;/a> 也可以算其中一种（ GB18030，与 UTF-8 类似，是一种变长编码格式，最大的优势就是兼容 &lt;a href="http://en.wikipedia.org/wiki/GBK">GBK&lt;/a>/&lt;a href="http://en.wikipedia.org/wiki/GB2312">GB2312&lt;/a> ）&lt;/p>
&lt;p>但是 Unicode 就能无痛的解决所有问题吗？答案是否定的。&lt;/p></description></item><item><title>Golang 内存模型（一）</title><link>https://theo.im/blog/2014/08/08/golang-memory-part-1/</link><pubDate>Fri, 08 Aug 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/08/08/golang-memory-part-1/</guid><description>开始之前 首先，这是一篇菜B写的文章，可能会有理解错误的地方，发现错误请斧正，谢谢。
为了治疗我的懒癌早期，我一次就不写得太多了，这个系列想写很久了，每次都是开了个头就没有再写。这次争取把写完，弄成一个系列。
此 nil 不等彼 nil 先声明，这个标题有标题党的嫌疑。
Go 的类型系统是比较奇葩的，nil 的含义跟其它语言有些差别，这里举个例子（可以直接进入 http://play.golang.org/p/ezFhXX0dnB 运行查看结果）：
package main import &amp;#34;fmt&amp;#34; type A struct { } func main() { var a *A = nil var ai interface{} = a var ei interface{} = nil fmt.Printf(&amp;#34;ai == nil: %v\n&amp;#34;, ai == nil) fmt.Printf(&amp;#34;ai == ei: %v\n&amp;#34;, ai == ei) fmt.Printf(&amp;#34;ei == a: %v\n&amp;#34;, a == ei) fmt.Printf(&amp;#34;ei == nil: %v\n&amp;#34;, ei == nil) } // -&amp;gt; 输出 // ai == nil: false // ai == ei: false // ei == a: false // ei == nil: true 这里 ai !</description></item><item><title>在 Go 中获取 stacktrace</title><link>https://theo.im/blog/2014/07/21/printing-stacktrace-in-go/</link><pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/07/21/printing-stacktrace-in-go/</guid><description>buf := make([]byte, 1&amp;lt;&amp;lt;16) // 获取 **所有** goroutine 的 stacktrace runtime.Stack(buf, true) // 如果需要获取 **当前** goroutine 的 stacktrace, 第二个参数需要为 `false` runtime.Stack(buf, true) fmt.Println(string(buf)) 太诡异了，居然要指定 buffer 的大小，用起来不方便。虽然可以给个“足够大” buffer 用来容纳 stacktrace，但是什么是“足够大”？
为了确认 runtime.Stack() 函数的 behavior，需要参考一下 Go 输出 stacktrace 的实现代码。该代码是使用 GOC 写成的。
A .goc file is a combination of a limited form of Go with C.
func Stack(b Slice, all bool) (n int) { uintptr pc, sp; // Stack pointer sp = runtime·getcallersp(&amp;amp;b); // Programer pointer pc = (uintptr)runtime·getcallerpc(&amp;amp;b); // 如果选择输出所有 goroutine 的 traceback, 挂起所有goroutine, // 在本函数完成后恢复 if(all) { runtime·semacquire(&amp;amp;runtime·worldsema, false); m-&amp;gt;gcing = 1; runtime·stoptheworld(); } if(b.</description></item><item><title>使用 FPM 创建 Python 的 RPM 包</title><link>https://theo.im/blog/2014/05/16/use-fpm-to-create-python-rpm-packages/</link><pubDate>Fri, 16 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/16/use-fpm-to-create-python-rpm-packages/</guid><description>生成 RPM 包太麻烦了，最近知道了一个名为 FPM 的神器，在此记录一下。
安装 FPM NOTE: 测试系统为 RedHat 系的 CentOS 6.3，编译 Python 2.7.6 的 RPM 包。
安装 Ruby 由于 FPM 使用 Ruby 写成，因此系统中需要安装 Ruby 的运行环境（这里 gem 的源改为了 taobao 的镜像）：
# Install ruby dependencies yum -y install ruby rubygems ruby-devel # Use taobao repo for ruby gems gem sources -a http://ruby.taobao.org/ # Remove origin repo from ruby gems gem sources --remove http://rubygems.org/ 通过 Gem 安装 FPM 在 Ruby 安装完成后，就可以使用 gem 安装 FPM 了：</description></item><item><title>RabbitMQ笔记（三）: Pika客户端（Python）发送大尺寸消息的问题</title><link>https://theo.im/blog/2014/05/15/rabbitmq-note-3-pika-send-large-message/</link><pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/15/rabbitmq-note-3-pika-send-large-message/</guid><description>问题描述 这个问题存在很久了，现象就是使用 Pika 库的客户端在发送大尺寸消息后，RabbitMQ 没有收到，Consumer 那里会认为消息已丢失。
NOTE: 即使在本文写时的最新版(v0.9.13)依然存在这个问题。
分析 因为网络状态很好，所以没有考虑网络的错误，直接考虑Pika库的问题。
那么第一步就是把 Pika 的代码拿来读一遍，主要看它是怎么发送消息的，经过一番探索，找到了 pika/adapters/base_connection.py 这个文件，来看看里面的内容：
def _handle_write(self): &amp;#34;&amp;#34;&amp;#34;Handle any outbound buffer writes that need to take place.&amp;#34;&amp;#34;&amp;#34; total_written = 0 if self.outbound_buffer: try: bytes_written = self.socket.send(self.outbound_buffer.popleft()) except socket.timeout: raise except socket.error, error: return self._handle_error(error) total_written += bytes_written return total_written 看出问题了吗？
来看看socket.send的文档吧：
Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above.</description></item><item><title>解决GitHub Pages的302转向问题</title><link>https://theo.im/blog/2014/05/14/resolve-302-redirection-on-github-pages/</link><pubDate>Wed, 14 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/14/resolve-302-redirection-on-github-pages/</guid><description>起因 NOTE: 如果给GitHub Pages使用的是子域名，按照GitHub Pages文档配置，不会出现该问题。
由于我在GitHub Pages上的搭的博客使用了theo.im这个根域名(Apex Domain)，在按照 GitHub Pages文档上提供的信息，对theo.im设置了A记录，但是通过执行命令：
curl -I http://theo.im/sitemap.xml 发现得到的是302转向，不符合Sitemap协议的要求：
A successful request will return an HTTP 200 response code; if you receive a different response, you should resubmit your request. The HTTP 200 response code only indicates that the search engine has received your Sitemap, not that the Sitemap itself or the URLs contained in it were valid.
解决 通过搜索，我发现需要使用ALIAS记录解析根域名，但是由于我之前使用的是DNSPod 的服务，不支持ALIAS记录，因此决定换加DNS域名解析商。
经过一番搜寻，找到了两家支持ALIAS记录的DNS域名解析商：
DNSimple: 全收费服务 PointDNS: 有免费的开发者账户 本着能用收费不用免费的原则，因此我选择了 DNSimple 来解析我的域名 (゜o゜(☆○=(-_-)</description></item><item><title>RabbitMQ笔记（一）: 通过Vagrant建立一个RabbitMQ服务器实验环境</title><link>https://theo.im/blog/2014/05/13/rabbitmq-note-1-setup-experimental-rabbitmq-environment-using-vagrant/</link><pubDate>Tue, 13 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/13/rabbitmq-note-1-setup-experimental-rabbitmq-environment-using-vagrant/</guid><description>安装Vagrant 在官方网站上，下载并安装Vagrant
NOTE: Vagrant 1.6版本对CentOS的guest支持不好，不能正确设置网络连接，需要升级到最新版或打上下面这个补丁: Fix issue reported at mitchellh#3649
下载并导入CentOS 6.3 Box vagrant box add --name centos63 &amp;#39;https://s3.amazonaws.com/itmat-public/centos-6.3-chef-10.14.2.box&amp;#39; 创建Vagrantfile Vagrantfile 文件内容如下:
# -*- mode: ruby -*- # vi: set ft=ruby : # Vagrantfile API/syntax version. Don&amp;#39;t touch unless you know what you&amp;#39;re doing! VAGRANTFILE_API_VERSION = &amp;#34;2&amp;#34; Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.box = &amp;#34;centos63&amp;#34; # 一个Host-Only的Network, IP地址可以自定义, 方便访问 config.vm.network :private_network, ip: &amp;#34;10.10.0.70&amp;#34;, netmask: &amp;#34;255.255.255.0&amp;#34; # config.vm.synced_folder &amp;#34;../&amp;#34;, &amp;#34;/vagrant&amp;#34; config.vm.provider :virtualbox do |vb| # 调节虚拟机CPU个数 vb.</description></item><item><title>RabbitMQ笔记（二）: 并发连接数</title><link>https://theo.im/blog/2014/05/13/rabbitmq-note-2-about-simultaneous-connections/</link><pubDate>Tue, 13 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/13/rabbitmq-note-2-about-simultaneous-connections/</guid><description>概要 对于服务器来说，并发连接数一直是一个需要考量的问题，因此在这里做一个简单的测试。
测试 在测试前，需要准备一个客户端环境，本文的环境是:
CentOS 6.3 Python 2.7.6 Kombu NOTE: 下文中的 IP 地址 10.10.0.70 为 RabbitMQ 服务器的 IP 地址
测试: 耗尽 rabbitmq 的 socket descriptors 首先, 编写一个脚本:
#!/usr/bin/env python # -*- coding: utf-8 -*- import os import logging import config logging.basicConfig(format=&amp;#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s&amp;#39;, level=logging.INFO) LOG = logging.getLogger(os.path.basename(__file__)) def main(): connections = [] while True: LOG.info(&amp;#34;Try to establish a new rabbit connection...&amp;#34;) connection = config.get_connection() connection.</description></item><item><title>Directory comparison for git difftool, with Beyond Compare 3</title><link>https://theo.im/blog/2012/10/27/directory-comparison-for-git-difftool/</link><pubDate>Sat, 27 Oct 2012 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2012/10/27/directory-comparison-for-git-difftool/</guid><description>For a long time, I didn&amp;rsquo;t know a way to do directory comparison using git difftool command, extdiff extension from Mercurial did perform much more superior than Git.
Though it may be a bit out of date, I just found that after v1.7.11, Git now supports directory comparison through --dir-diff option, fantastic!
UPDATE 12/11/2012: You will need v1.8.0 version of msysgit installed, as noted by Scooter Software (Reference).
So here is a list of steps for me to make Beyond Compare 3 and Git directory comparison work under Windows.</description></item></channel></rss>