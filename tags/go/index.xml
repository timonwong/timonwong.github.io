<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Go on Timon Wong</title><link>https://theo.im/tags/go/</link><description>Recent content in Go on Timon Wong</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© timonwong</copyright><lastBuildDate>Fri, 08 Aug 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://theo.im/tags/go/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 内存模型（一）</title><link>https://theo.im/blog/2014/08/08/golang-memory-part-1/</link><pubDate>Fri, 08 Aug 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/08/08/golang-memory-part-1/</guid><description>开始之前 首先，这是一篇菜B写的文章，可能会有理解错误的地方，发现错误请斧正，谢谢。
为了治疗我的懒癌早期，我一次就不写得太多了，这个系列想写很久了，每次都是开了个头就没有再写。这次争取把写完，弄成一个系列。
此 nil 不等彼 nil 先声明，这个标题有标题党的嫌疑。
Go 的类型系统是比较奇葩的，nil 的含义跟其它语言有些差别，这里举个例子（可以直接进入 http://play.golang.org/p/ezFhXX0dnB 运行查看结果）：
package main import &amp;#34;fmt&amp;#34; type A struct { } func main() { var a *A = nil var ai interface{} = a var ei interface{} = nil fmt.Printf(&amp;#34;ai == nil: %v\n&amp;#34;, ai == nil) fmt.Printf(&amp;#34;ai == ei: %v\n&amp;#34;, ai == ei) fmt.Printf(&amp;#34;ei == a: %v\n&amp;#34;, a == ei) fmt.Printf(&amp;#34;ei == nil: %v\n&amp;#34;, ei == nil) } // -&amp;gt; 输出 // ai == nil: false // ai == ei: false // ei == a: false // ei == nil: true 这里 ai !</description></item><item><title>在 Go 中获取 stacktrace</title><link>https://theo.im/blog/2014/07/21/printing-stacktrace-in-go/</link><pubDate>Mon, 21 Jul 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/07/21/printing-stacktrace-in-go/</guid><description>buf := make([]byte, 1&amp;lt;&amp;lt;16) // 获取 **所有** goroutine 的 stacktrace runtime.Stack(buf, true) // 如果需要获取 **当前** goroutine 的 stacktrace, 第二个参数需要为 `false` runtime.Stack(buf, true) fmt.Println(string(buf)) 太诡异了，居然要指定 buffer 的大小，用起来不方便。虽然可以给个“足够大” buffer 用来容纳 stacktrace，但是什么是“足够大”？
为了确认 runtime.Stack() 函数的 behavior，需要参考一下 Go 输出 stacktrace 的实现代码。该代码是使用 GOC 写成的。
A .goc file is a combination of a limited form of Go with C.
func Stack(b Slice, all bool) (n int) { uintptr pc, sp; // Stack pointer sp = runtime·getcallersp(&amp;amp;b); // Programer pointer pc = (uintptr)runtime·getcallerpc(&amp;amp;b); // 如果选择输出所有 goroutine 的 traceback, 挂起所有goroutine, // 在本函数完成后恢复 if(all) { runtime·semacquire(&amp;amp;runtime·worldsema, false); m-&amp;gt;gcing = 1; runtime·stoptheworld(); } if(b.</description></item></channel></rss>