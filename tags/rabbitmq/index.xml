<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>RabbitMQ on Timon Wong</title><link>https://theo.im/tags/rabbitmq/</link><description>Recent content in RabbitMQ on Timon Wong</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© timonwong</copyright><lastBuildDate>Thu, 15 May 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://theo.im/tags/rabbitmq/index.xml" rel="self" type="application/rss+xml"/><item><title>RabbitMQ笔记（三）: Pika客户端（Python）发送大尺寸消息的问题</title><link>https://theo.im/blog/2014/05/15/rabbitmq-note-3-pika-send-large-message/</link><pubDate>Thu, 15 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/15/rabbitmq-note-3-pika-send-large-message/</guid><description>问题描述 这个问题存在很久了，现象就是使用 Pika 库的客户端在发送大尺寸消息后，RabbitMQ 没有收到，Consumer 那里会认为消息已丢失。
NOTE: 即使在本文写时的最新版(v0.9.13)依然存在这个问题。
分析 因为网络状态很好，所以没有考虑网络的错误，直接考虑Pika库的问题。
那么第一步就是把 Pika 的代码拿来读一遍，主要看它是怎么发送消息的，经过一番探索，找到了 pika/adapters/base_connection.py 这个文件，来看看里面的内容：
def _handle_write(self): &amp;#34;&amp;#34;&amp;#34;Handle any outbound buffer writes that need to take place.&amp;#34;&amp;#34;&amp;#34; total_written = 0 if self.outbound_buffer: try: bytes_written = self.socket.send(self.outbound_buffer.popleft()) except socket.timeout: raise except socket.error, error: return self._handle_error(error) total_written += bytes_written return total_written 看出问题了吗？
来看看socket.send的文档吧：
Send data to the socket. The socket must be connected to a remote socket. The optional flags argument has the same meaning as for recv() above.</description></item><item><title>RabbitMQ笔记（一）: 通过Vagrant建立一个RabbitMQ服务器实验环境</title><link>https://theo.im/blog/2014/05/13/rabbitmq-note-1-setup-experimental-rabbitmq-environment-using-vagrant/</link><pubDate>Tue, 13 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/13/rabbitmq-note-1-setup-experimental-rabbitmq-environment-using-vagrant/</guid><description>安装Vagrant 在官方网站上，下载并安装Vagrant
NOTE: Vagrant 1.6版本对CentOS的guest支持不好，不能正确设置网络连接，需要升级到最新版或打上下面这个补丁: Fix issue reported at mitchellh#3649
下载并导入CentOS 6.3 Box vagrant box add --name centos63 &amp;#39;https://s3.amazonaws.com/itmat-public/centos-6.3-chef-10.14.2.box&amp;#39; 创建Vagrantfile Vagrantfile 文件内容如下:
# -*- mode: ruby -*- # vi: set ft=ruby : # Vagrantfile API/syntax version. Don&amp;#39;t touch unless you know what you&amp;#39;re doing! VAGRANTFILE_API_VERSION = &amp;#34;2&amp;#34; Vagrant.configure(VAGRANTFILE_API_VERSION) do |config| config.vm.box = &amp;#34;centos63&amp;#34; # 一个Host-Only的Network, IP地址可以自定义, 方便访问 config.vm.network :private_network, ip: &amp;#34;10.10.0.70&amp;#34;, netmask: &amp;#34;255.255.255.0&amp;#34; # config.vm.synced_folder &amp;#34;../&amp;#34;, &amp;#34;/vagrant&amp;#34; config.vm.provider :virtualbox do |vb| # 调节虚拟机CPU个数 vb.</description></item><item><title>RabbitMQ笔记（二）: 并发连接数</title><link>https://theo.im/blog/2014/05/13/rabbitmq-note-2-about-simultaneous-connections/</link><pubDate>Tue, 13 May 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/05/13/rabbitmq-note-2-about-simultaneous-connections/</guid><description>概要 对于服务器来说，并发连接数一直是一个需要考量的问题，因此在这里做一个简单的测试。
测试 在测试前，需要准备一个客户端环境，本文的环境是:
CentOS 6.3 Python 2.7.6 Kombu NOTE: 下文中的 IP 地址 10.10.0.70 为 RabbitMQ 服务器的 IP 地址
测试: 耗尽 rabbitmq 的 socket descriptors 首先, 编写一个脚本:
#!/usr/bin/env python # -*- coding: utf-8 -*- import os import logging import config logging.basicConfig(format=&amp;#39;%(asctime)s- %(name)s- %(levelname)s- %(message)s&amp;#39;, level=logging.INFO) LOG = logging.getLogger(os.path.basename(__file__)) def main(): connections = [] while True: LOG.info(&amp;#34;Try to establish a new rabbit connection...&amp;#34;) connection = config.get_connection() connection.</description></item></channel></rss>