<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Golang on Timon Wong</title><link>https://theo.im/tags/golang/</link><description>Recent content in Golang on Timon Wong</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><copyright>© timonwong</copyright><lastBuildDate>Fri, 08 Aug 2014 00:00:00 +0000</lastBuildDate><atom:link href="https://theo.im/tags/golang/index.xml" rel="self" type="application/rss+xml"/><item><title>Golang 内存模型（一）</title><link>https://theo.im/blog/2014/08/08/golang-memory-part-1/</link><pubDate>Fri, 08 Aug 2014 00:00:00 +0000</pubDate><guid>https://theo.im/blog/2014/08/08/golang-memory-part-1/</guid><description>开始之前 首先，这是一篇菜B写的文章，可能会有理解错误的地方，发现错误请斧正，谢谢。
为了治疗我的懒癌早期，我一次就不写得太多了，这个系列想写很久了，每次都是开了个头就没有再写。这次争取把写完，弄成一个系列。
此 nil 不等彼 nil 先声明，这个标题有标题党的嫌疑。
Go 的类型系统是比较奇葩的，nil 的含义跟其它语言有些差别，这里举个例子（可以直接进入 http://play.golang.org/p/ezFhXX0dnB 运行查看结果）：
package main import &amp;#34;fmt&amp;#34; type A struct { } func main() { var a *A = nil var ai interface{} = a var ei interface{} = nil fmt.Printf(&amp;#34;ai == nil: %v\n&amp;#34;, ai == nil) fmt.Printf(&amp;#34;ai == ei: %v\n&amp;#34;, ai == ei) fmt.Printf(&amp;#34;ei == a: %v\n&amp;#34;, a == ei) fmt.Printf(&amp;#34;ei == nil: %v\n&amp;#34;, ei == nil) } // -&amp;gt; 输出 // ai == nil: false // ai == ei: false // ei == a: false // ei == nil: true 这里 ai !</description></item></channel></rss>